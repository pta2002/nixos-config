diff --git a/options.c b/options.c
index de02407..69245d6 100644
--- a/options.c
+++ b/options.c
@@ -26,155 +26,154 @@
 #include <unistd.h>
 
 opt_t _options;
-const opt_t *options = (const opt_t*) &_options;
+const opt_t *options = (const opt_t *)&_options;
 
-void print_usage(void)
-{
-	printf("usage: sxiv [-abcfhiopqrtvZ] [-A FRAMERATE] [-e WID] [-G GAMMA] "
-	       "[-g GEOMETRY] [-N NAME] [-n NUM] [-S DELAY] [-s MODE] [-z ZOOM] "
-	       "FILES...\n");
+void print_usage(void) {
+  printf("usage: sxiv [-abcfhiopqrtvTZ] [-A FRAMERATE] [-e WID] [-G GAMMA] "
+         "[-g GEOMETRY] [-N NAME] [-n NUM] [-S DELAY] [-s MODE] [-z ZOOM] "
+         "FILES...\n");
 }
 
-void print_version(void)
-{
-	puts("sxiv " VERSION);
-}
+void print_version(void) { puts("sxiv " VERSION); }
 
-void parse_options(int argc, char **argv)
-{
-	int n, opt;
-	char *end, *s;
-	const char *scalemodes = "dfwh";
+void parse_options(int argc, char **argv) {
+  int n, opt;
+  char *end, *s;
+  const char *scalemodes = "dfwh";
 
-	progname = strrchr(argv[0], '/');
-	progname = progname ? progname + 1 : argv[0];
+  progname = strrchr(argv[0], '/');
+  progname = progname ? progname + 1 : argv[0];
 
-	_options.from_stdin = false;
-	_options.to_stdout = false;
-	_options.recursive = false;
-	_options.startnum = 0;
+  _options.from_stdin = false;
+  _options.to_stdout = false;
+  _options.recursive = false;
+  _options.startnum = 0;
 
-	_options.scalemode = SCALE_DOWN;
-	_options.zoom = 1.0;
-	_options.animate = false;
-	_options.gamma = 0;
-	_options.slideshow = 0;
-	_options.framerate = 0;
+  _options.scalemode = SCALE_DOWN;
+  _options.zoom = 1.0;
+  _options.animate = false;
+  _options.gamma = 0;
+  _options.slideshow = 0;
+  _options.framerate = 0;
 
-	_options.fullscreen = false;
-	_options.embed = 0;
-	_options.hide_bar = false;
-	_options.geometry = NULL;
-	_options.res_name = NULL;
+  _options.fullscreen = false;
+  _options.embed = 0;
+  _options.always_on_top = false;
+  _options.hide_bar = false;
+  _options.geometry = NULL;
+  _options.res_name = NULL;
 
-	_options.quiet = false;
-	_options.thumb_mode = false;
-	_options.clean_cache = false;
-	_options.private_mode = false;
+  _options.quiet = false;
+  _options.thumb_mode = false;
+  _options.clean_cache = false;
+  _options.private_mode = false;
 
-	while ((opt = getopt(argc, argv, "A:abce:fG:g:hin:N:opqrS:s:tvZz:")) != -1) {
-		switch (opt) {
-			case '?':
-				print_usage();
-				exit(EXIT_FAILURE);
-			case 'A':
-				n = strtol(optarg, &end, 0);
-				if (*end != '\0' || n <= 0)
-					error(EXIT_FAILURE, 0, "Invalid argument for option -A: %s", optarg);
-				_options.framerate = n;
-				/* fall through */
-			case 'a':
-				_options.animate = true;
-				break;
-			case 'b':
-				_options.hide_bar = true;
-				break;
-			case 'c':
-				_options.clean_cache = true;
-				break;
-			case 'e':
-				n = strtol(optarg, &end, 0);
-				if (*end != '\0')
-					error(EXIT_FAILURE, 0, "Invalid argument for option -e: %s", optarg);
-				_options.embed = n;
-				break;
-			case 'f':
-				_options.fullscreen = true;
-				break;
-			case 'G':
-				n = strtol(optarg, &end, 0);
-				if (*end != '\0')
-					error(EXIT_FAILURE, 0, "Invalid argument for option -G: %s", optarg);
-				_options.gamma = n;
-				break;
-			case 'g':
-				_options.geometry = optarg;
-				break;
-			case 'h':
-				print_usage();
-				exit(EXIT_SUCCESS);
-			case 'i':
-				_options.from_stdin = true;
-				break;
-			case 'n':
-				n = strtol(optarg, &end, 0);
-				if (*end != '\0' || n <= 0)
-					error(EXIT_FAILURE, 0, "Invalid argument for option -n: %s", optarg);
-				_options.startnum = n - 1;
-				break;
-			case 'N':
-				_options.res_name = optarg;
-				break;
-			case 'o':
-				_options.to_stdout = true;
-				break;
-			case 'p':
-				_options.private_mode = true;
-				break;
-			case 'q':
-				_options.quiet = true;
-				break;
-			case 'r':
-				_options.recursive = true;
-				break;
-			case 'S':
-				n = strtof(optarg, &end) * 10;
-				if (*end != '\0' || n <= 0)
-					error(EXIT_FAILURE, 0, "Invalid argument for option -S: %s", optarg);
-				_options.slideshow = n;
-				break;
-			case 's':
-				s = strchr(scalemodes, optarg[0]);
-				if (s == NULL || *s == '\0' || strlen(optarg) != 1)
-					error(EXIT_FAILURE, 0, "Invalid argument for option -s: %s", optarg);
-				_options.scalemode = s - scalemodes;
-				break;
-			case 't':
-				_options.thumb_mode = true;
-				break;
-			case 'v':
-				print_version();
-				exit(EXIT_SUCCESS);
-			case 'Z':
-				_options.scalemode = SCALE_ZOOM;
-				_options.zoom = 1.0;
-				break;
-			case 'z':
-				n = strtol(optarg, &end, 0);
-				if (*end != '\0' || n <= 0)
-					error(EXIT_FAILURE, 0, "Invalid argument for option -z: %s", optarg);
-				_options.scalemode = SCALE_ZOOM;
-				_options.zoom = (float) n / 100.0;
-				break;
-		}
-	}
+  while ((opt = getopt(argc, argv, "A:abce:fG:g:hin:N:opqrS:s:tTvZz:")) != -1) {
+    switch (opt) {
+    case '?':
+      print_usage();
+      exit(EXIT_FAILURE);
+    case 'A':
+      n = strtol(optarg, &end, 0);
+      if (*end != '\0' || n <= 0)
+        error(EXIT_FAILURE, 0, "Invalid argument for option -A: %s", optarg);
+      _options.framerate = n;
+      /* fall through */
+    case 'a':
+      _options.animate = true;
+      break;
+    case 'b':
+      _options.hide_bar = true;
+      break;
+    case 'c':
+      _options.clean_cache = true;
+      break;
+    case 'e':
+      n = strtol(optarg, &end, 0);
+      if (*end != '\0')
+        error(EXIT_FAILURE, 0, "Invalid argument for option -e: %s", optarg);
+      _options.embed = n;
+      break;
+    case 'f':
+      _options.fullscreen = true;
+      break;
+    case 'G':
+      n = strtol(optarg, &end, 0);
+      if (*end != '\0')
+        error(EXIT_FAILURE, 0, "Invalid argument for option -G: %s", optarg);
+      _options.gamma = n;
+      break;
+    case 'g':
+      _options.geometry = optarg;
+      break;
+    case 'h':
+      print_usage();
+      exit(EXIT_SUCCESS);
+    case 'i':
+      _options.from_stdin = true;
+      break;
+    case 'n':
+      n = strtol(optarg, &end, 0);
+      if (*end != '\0' || n <= 0)
+        error(EXIT_FAILURE, 0, "Invalid argument for option -n: %s", optarg);
+      _options.startnum = n - 1;
+      break;
+    case 'N':
+      _options.res_name = optarg;
+      break;
+    case 'o':
+      _options.to_stdout = true;
+      break;
+    case 'p':
+      _options.private_mode = true;
+      break;
+    case 'q':
+      _options.quiet = true;
+      break;
+    case 'r':
+      _options.recursive = true;
+      break;
+    case 'S':
+      n = strtof(optarg, &end) * 10;
+      if (*end != '\0' || n <= 0)
+        error(EXIT_FAILURE, 0, "Invalid argument for option -S: %s", optarg);
+      _options.slideshow = n;
+      break;
+    case 's':
+      s = strchr(scalemodes, optarg[0]);
+      if (s == NULL || *s == '\0' || strlen(optarg) != 1)
+        error(EXIT_FAILURE, 0, "Invalid argument for option -s: %s", optarg);
+      _options.scalemode = s - scalemodes;
+      break;
+    case 't':
+      _options.thumb_mode = true;
+      break;
+    case 'T':
+      _options.always_on_top = true;
+      break;
+    case 'v':
+      print_version();
+      exit(EXIT_SUCCESS);
+    case 'Z':
+      _options.scalemode = SCALE_ZOOM;
+      _options.zoom = 1.0;
+      break;
+    case 'z':
+      n = strtol(optarg, &end, 0);
+      if (*end != '\0' || n <= 0)
+        error(EXIT_FAILURE, 0, "Invalid argument for option -z: %s", optarg);
+      _options.scalemode = SCALE_ZOOM;
+      _options.zoom = (float)n / 100.0;
+      break;
+    }
+  }
 
-	_options.filenames = argv + optind;
-	_options.filecnt = argc - optind;
+  _options.filenames = argv + optind;
+  _options.filecnt = argc - optind;
 
-	if (_options.filecnt == 1 && STREQ(_options.filenames[0], "-")) {
-		_options.filenames++;
-		_options.filecnt--;
-		_options.from_stdin = true;
-	}
+  if (_options.filecnt == 1 && STREQ(_options.filenames[0], "-")) {
+    _options.filenames++;
+    _options.filecnt--;
+    _options.from_stdin = true;
+  }
 }
diff --git a/sxiv.1 b/sxiv.1
index eff3d66..7d68081 100644
--- a/sxiv.1
+++ b/sxiv.1
@@ -54,6 +54,9 @@ Embed sxiv's window into window whose ID is
 .B \-f
 Start in fullscreen mode.
 .TP
+.B \-T
+Make window always on top.
+.TP
 .BI "\-G " GAMMA
 Set image gamma to GAMMA (-32..32).
 .TP
diff --git a/sxiv.h b/sxiv.h
index 707eba7..661f033 100644
--- a/sxiv.h
+++ b/sxiv.h
@@ -19,13 +19,13 @@
 #ifndef SXIV_H
 #define SXIV_H
 
+#include <Imlib2.h>
+#include <X11/Xlib.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <sys/time.h>
 #include <sys/types.h>
-#include <Imlib2.h>
-#include <X11/Xlib.h>
 
 /*
  * Annotation for functions called in cleanup().
@@ -34,99 +34,82 @@
 #define CLEANUP
 
 #ifndef MIN
-#define MIN(a,b) ((a) < (b) ? (a) : (b))
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
 #ifndef MAX
-#define MAX(a,b) ((a) > (b) ? (a) : (b))
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
 #endif
 
 #define ARRLEN(a) (sizeof(a) / sizeof((a)[0]))
 
-#define STREQ(s1,s2) (strcmp((s1), (s2)) == 0)
+#define STREQ(s1, s2) (strcmp((s1), (s2)) == 0)
 
-#define TV_DIFF(t1,t2) (((t1)->tv_sec  - (t2)->tv_sec ) * 1000 + \
-                        ((t1)->tv_usec - (t2)->tv_usec) / 1000)
+#define TV_DIFF(t1, t2)                                                        \
+  (((t1)->tv_sec - (t2)->tv_sec) * 1000 +                                      \
+   ((t1)->tv_usec - (t2)->tv_usec) / 1000)
 
-#define TV_SET_MSEC(tv,t) {             \
-  (tv)->tv_sec  = (t) / 1000;           \
-  (tv)->tv_usec = (t) % 1000 * 1000;    \
-}
+#define TV_SET_MSEC(tv, t)                                                     \
+  {                                                                            \
+    (tv)->tv_sec = (t) / 1000;                                                 \
+    (tv)->tv_usec = (t) % 1000 * 1000;                                         \
+  }
 
-#define TV_ADD_MSEC(tv,t) {             \
-  (tv)->tv_sec  += (t) / 1000;          \
-  (tv)->tv_usec += (t) % 1000 * 1000;   \
-}
+#define TV_ADD_MSEC(tv, t)                                                     \
+  {                                                                            \
+    (tv)->tv_sec += (t) / 1000;                                                \
+    (tv)->tv_usec += (t) % 1000 * 1000;                                        \
+  }
 
-typedef enum {
-	BO_BIG_ENDIAN,
-	BO_LITTLE_ENDIAN
-} byteorder_t;
+typedef enum { BO_BIG_ENDIAN, BO_LITTLE_ENDIAN } byteorder_t;
 
-typedef enum {
-	MODE_IMAGE,
-	MODE_THUMB
-} appmode_t;
+typedef enum { MODE_IMAGE, MODE_THUMB } appmode_t;
 
 typedef enum {
-	DIR_LEFT  = 1,
-	DIR_RIGHT = 2,
-	DIR_UP    = 4,
-	DIR_DOWN  = 8
+  DIR_LEFT = 1,
+  DIR_RIGHT = 2,
+  DIR_UP = 4,
+  DIR_DOWN = 8
 } direction_t;
 
-typedef enum {
-	DEGREE_90  = 1,
-	DEGREE_180 = 2,
-	DEGREE_270 = 3
-} degree_t;
+typedef enum { DEGREE_90 = 1, DEGREE_180 = 2, DEGREE_270 = 3 } degree_t;
 
-typedef enum {
-	FLIP_HORIZONTAL = 1,
-	FLIP_VERTICAL   = 2
-} flipdir_t;
+typedef enum { FLIP_HORIZONTAL = 1, FLIP_VERTICAL = 2 } flipdir_t;
 
 typedef enum {
-	SCALE_DOWN,
-	SCALE_FIT,
-	SCALE_WIDTH,
-	SCALE_HEIGHT,
-	SCALE_ZOOM
+  SCALE_DOWN,
+  SCALE_FIT,
+  SCALE_WIDTH,
+  SCALE_HEIGHT,
+  SCALE_ZOOM
 } scalemode_t;
 
-typedef enum {
-	DRAG_RELATIVE,
-	DRAG_ABSOLUTE
-} dragmode_t;
+typedef enum { DRAG_RELATIVE, DRAG_ABSOLUTE } dragmode_t;
 
 typedef enum {
-	CURSOR_ARROW,
-	CURSOR_DRAG,
-	CURSOR_WATCH,
-	CURSOR_LEFT,
-	CURSOR_RIGHT,
-	CURSOR_NONE,
-
-	CURSOR_COUNT
+  CURSOR_ARROW,
+  CURSOR_DRAG,
+  CURSOR_WATCH,
+  CURSOR_LEFT,
+  CURSOR_RIGHT,
+  CURSOR_NONE,
+
+  CURSOR_COUNT
 } cursor_t;
 
-typedef enum {
-	FF_WARN    = 1,
-	FF_MARK    = 2,
-	FF_TN_INIT = 4
-} fileflags_t;
+typedef enum { FF_WARN = 1, FF_MARK = 2, FF_TN_INIT = 4 } fileflags_t;
 
 typedef struct {
-	const char *name; /* as given by user */
-	const char *path; /* always absolute */
-	fileflags_t flags;
+  const char *name; /* as given by user */
+  const char *path; /* always absolute */
+  fileflags_t flags;
 } fileinfo_t;
 
 /* timeouts in milliseconds: */
 enum {
-	TO_REDRAW_RESIZE = 75,
-	TO_REDRAW_THUMBS = 200,
-	TO_CURSOR_HIDE   = 1200,
-	TO_DOUBLE_CLICK  = 300
+  TO_REDRAW_RESIZE = 75,
+  TO_REDRAW_THUMBS = 200,
+  TO_CURSOR_HIDE = 1200,
+  TO_DOUBLE_CLICK = 300
 };
 
 typedef void (*timeout_f)(void);
@@ -137,21 +120,19 @@ typedef struct opt opt_t;
 typedef struct tns tns_t;
 typedef struct win win_t;
 
-
 /* autoreload.c */
 
 struct arl {
-	int fd;
-	int wd_dir;
-	int wd_file;
-	char *filename;
+  int fd;
+  int wd_dir;
+  int wd_file;
+  char *filename;
 };
 
-void arl_init(arl_t*);
-void arl_cleanup(arl_t*);
-void arl_setup(arl_t*, const char* /* result of realpath(3) */);
-bool arl_handle(arl_t*);
-
+void arl_init(arl_t *);
+void arl_cleanup(arl_t *);
+void arl_setup(arl_t *, const char * /* result of realpath(3) */);
+bool arl_handle(arl_t *);
 
 /* commands.c */
 
@@ -164,285 +145,278 @@ typedef bool (*cmd_f)(arg_t);
 
 typedef enum {
 #include "commands.lst"
-	CMD_COUNT
+  CMD_COUNT
 } cmd_id_t;
 
 typedef struct {
-	int mode;
-	cmd_f func;
+  int mode;
+  cmd_f func;
 } cmd_t;
 
 typedef struct {
-	unsigned int mask;
-	KeySym ksym;
-	cmd_id_t cmd;
-	arg_t arg;
+  unsigned int mask;
+  KeySym ksym;
+  cmd_id_t cmd;
+  arg_t arg;
 } keymap_t;
 
 typedef struct {
-	unsigned int mask;
-	unsigned int button;
-	cmd_id_t cmd;
-	arg_t arg;
+  unsigned int mask;
+  unsigned int button;
+  cmd_id_t cmd;
+  arg_t arg;
 } button_t;
 
 extern const cmd_t cmds[CMD_COUNT];
 
-
 /* image.c */
 
 typedef struct {
-	Imlib_Image im;
-	unsigned int delay;
+  Imlib_Image im;
+  unsigned int delay;
 } img_frame_t;
 
 typedef struct {
-	img_frame_t *frames;
-	int cap;
-	int cnt;
-	int sel;
-	bool animate;
-	int framedelay;
-	int length;
+  img_frame_t *frames;
+  int cap;
+  int cnt;
+  int sel;
+  bool animate;
+  int framedelay;
+  int length;
 } multi_img_t;
 
 struct img {
-	Imlib_Image im;
-	int w;
-	int h;
+  Imlib_Image im;
+  int w;
+  int h;
 
-	win_t *win;
-	float x;
-	float y;
+  win_t *win;
+  float x;
+  float y;
 
-	scalemode_t scalemode;
-	float zoom;
+  scalemode_t scalemode;
+  float zoom;
 
-	bool checkpan;
-	bool dirty;
-	bool aa;
-	bool alpha;
+  bool checkpan;
+  bool dirty;
+  bool aa;
+  bool alpha;
 
-	Imlib_Color_Modifier cmod;
-	int gamma;
+  Imlib_Color_Modifier cmod;
+  int gamma;
 
-	struct {
-		bool on;
-		int delay;
-	} ss;
+  struct {
+    bool on;
+    int delay;
+  } ss;
 
-	multi_img_t multi;
+  multi_img_t multi;
 };
 
-void img_init(img_t*, win_t*);
-bool img_load(img_t*, const fileinfo_t*);
-CLEANUP void img_close(img_t*, bool);
-void img_render(img_t*);
-bool img_fit_win(img_t*, scalemode_t);
-bool img_zoom(img_t*, float);
-bool img_zoom_in(img_t*);
-bool img_zoom_out(img_t*);
-bool img_pos(img_t*, float, float);
-bool img_move(img_t*, float, float);
-bool img_pan(img_t*, direction_t, int);
-bool img_pan_edge(img_t*, direction_t);
-void img_rotate(img_t*, degree_t);
-void img_flip(img_t*, flipdir_t);
-void img_toggle_antialias(img_t*);
-bool img_change_gamma(img_t*, int);
-bool img_frame_navigate(img_t*, int);
-bool img_frame_animate(img_t*);
-
+void img_init(img_t *, win_t *);
+bool img_load(img_t *, const fileinfo_t *);
+CLEANUP void img_close(img_t *, bool);
+void img_render(img_t *);
+bool img_fit_win(img_t *, scalemode_t);
+bool img_zoom(img_t *, float);
+bool img_zoom_in(img_t *);
+bool img_zoom_out(img_t *);
+bool img_pos(img_t *, float, float);
+bool img_move(img_t *, float, float);
+bool img_pan(img_t *, direction_t, int);
+bool img_pan_edge(img_t *, direction_t);
+void img_rotate(img_t *, degree_t);
+void img_flip(img_t *, flipdir_t);
+void img_toggle_antialias(img_t *);
+bool img_change_gamma(img_t *, int);
+bool img_frame_navigate(img_t *, int);
+bool img_frame_animate(img_t *);
 
 /* options.c */
 
 struct opt {
-	/* file list: */
-	char **filenames;
-	bool from_stdin;
-	bool to_stdout;
-	bool recursive;
-	int filecnt;
-	int startnum;
-
-	/* image: */
-	scalemode_t scalemode;
-	float zoom;
-	bool animate;
-	int gamma;
-	int slideshow;
-	int framerate;
-
-	/* window: */
-	bool fullscreen;
-	bool hide_bar;
-	long embed;
-	char *geometry;
-	char *res_name;
-
-	/* misc flags: */
-	bool quiet;
-	bool thumb_mode;
-	bool clean_cache;
-	bool private_mode;
+  /* file list: */
+  char **filenames;
+  bool from_stdin;
+  bool to_stdout;
+  bool recursive;
+  int filecnt;
+  int startnum;
+
+  /* image: */
+  scalemode_t scalemode;
+  float zoom;
+  bool animate;
+  int gamma;
+  int slideshow;
+  int framerate;
+
+  /* window: */
+  bool fullscreen;
+  bool hide_bar;
+  bool always_on_top;
+  long embed;
+  char *geometry;
+  char *res_name;
+
+  /* misc flags: */
+  bool quiet;
+  bool thumb_mode;
+  bool clean_cache;
+  bool private_mode;
 };
 
 extern const opt_t *options;
 
 void print_usage(void);
 void print_version(void);
-void parse_options(int, char**);
-
+void parse_options(int, char **);
 
 /* thumbs.c */
 
 typedef struct {
-	Imlib_Image im;
-	int w;
-	int h;
-	int x;
-	int y;
+  Imlib_Image im;
+  int w;
+  int h;
+  int x;
+  int y;
 } thumb_t;
 
 struct tns {
-	fileinfo_t *files;
-	thumb_t *thumbs;
-	const int *cnt;
-	int *sel;
-	int initnext;
-	int loadnext;
-	int first, end;
-	int r_first, r_end;
-
-	win_t *win;
-	int x;
-	int y;
-	int cols;
-	int rows;
-	int zl;
-	int bw;
-	int dim;
-
-	bool dirty;
+  fileinfo_t *files;
+  thumb_t *thumbs;
+  const int *cnt;
+  int *sel;
+  int initnext;
+  int loadnext;
+  int first, end;
+  int r_first, r_end;
+
+  win_t *win;
+  int x;
+  int y;
+  int cols;
+  int rows;
+  int zl;
+  int bw;
+  int dim;
+
+  bool dirty;
 };
 
-void tns_clean_cache(tns_t*);
-void tns_init(tns_t*, fileinfo_t*, const int*, int*, win_t*);
-CLEANUP void tns_free(tns_t*);
-bool tns_load(tns_t*, int, bool, bool);
-void tns_unload(tns_t*, int);
-void tns_render(tns_t*);
-void tns_mark(tns_t*, int, bool);
-void tns_highlight(tns_t*, int, bool);
-bool tns_move_selection(tns_t*, direction_t, int);
-bool tns_scroll(tns_t*, direction_t, bool);
-bool tns_zoom(tns_t*, int);
-int tns_translate(tns_t*, int, int);
-
+void tns_clean_cache(tns_t *);
+void tns_init(tns_t *, fileinfo_t *, const int *, int *, win_t *);
+CLEANUP void tns_free(tns_t *);
+bool tns_load(tns_t *, int, bool, bool);
+void tns_unload(tns_t *, int);
+void tns_render(tns_t *);
+void tns_mark(tns_t *, int, bool);
+void tns_highlight(tns_t *, int, bool);
+bool tns_move_selection(tns_t *, direction_t, int);
+bool tns_scroll(tns_t *, direction_t, bool);
+bool tns_zoom(tns_t *, int);
+int tns_translate(tns_t *, int, int);
 
 /* util.c */
 
 #include <dirent.h>
 
 typedef struct {
-	DIR *dir;
-	char *name;
-	int d;
-	bool recursive;
-
-	char **stack;
-	int stcap;
-	int stlen;
+  DIR *dir;
+  char *name;
+  int d;
+  bool recursive;
+
+  char **stack;
+  int stcap;
+  int stlen;
 } r_dir_t;
 
 extern const char *progname;
 
-void* emalloc(size_t);
-void* erealloc(void*, size_t);
-char* estrdup(const char*);
-void error(int, int, const char*, ...);
-void size_readable(float*, const char**);
-int r_opendir(r_dir_t*, const char*, bool);
-int r_closedir(r_dir_t*);
-char* r_readdir(r_dir_t*, bool);
-int r_mkdir(char*);
-
+void *emalloc(size_t);
+void *erealloc(void *, size_t);
+char *estrdup(const char *);
+void error(int, int, const char *, ...);
+void size_readable(float *, const char **);
+int r_opendir(r_dir_t *, const char *, bool);
+int r_closedir(r_dir_t *);
+char *r_readdir(r_dir_t *, bool);
+int r_mkdir(char *);
 
 /* window.c */
 
-#include <X11/Xutil.h>
 #include <X11/Xft/Xft.h>
+#include <X11/Xutil.h>
 
-enum {
-	BAR_L_LEN = 512,
-	BAR_R_LEN = 64
-};
+enum { BAR_L_LEN = 512, BAR_R_LEN = 64 };
 
 enum {
-	ATOM_WM_DELETE_WINDOW,
-	ATOM__NET_WM_NAME,
-	ATOM__NET_WM_ICON_NAME,
-	ATOM__NET_WM_ICON,
-	ATOM__NET_WM_STATE,
-	ATOM__NET_WM_STATE_FULLSCREEN,
-	ATOM_COUNT
+  ATOM_WM_DELETE_WINDOW,
+  ATOM__NET_WM_NAME,
+  ATOM__NET_WM_ICON_NAME,
+  ATOM__NET_WM_ICON,
+  ATOM__NET_WM_STATE,
+  ATOM__NET_WM_STATE_FULLSCREEN,
+  ATOM__NET_WM_STATE_ABOVE,
+  ATOM_COUNT
 };
 
 typedef struct {
-	Display *dpy;
-	int scr;
-	int scrw, scrh;
-	Visual *vis;
-	Colormap cmap;
-	int depth;
+  Display *dpy;
+  int scr;
+  int scrw, scrh;
+  Visual *vis;
+  Colormap cmap;
+  int depth;
 } win_env_t;
 
 typedef struct {
-	size_t size;
-	char *p;
-	char *buf;
+  size_t size;
+  char *p;
+  char *buf;
 } win_bar_t;
 
 struct win {
-	Window xwin;
-	win_env_t env;
-
-	XftColor bg;
-	XftColor fg;
-
-	int x;
-	int y;
-	unsigned int w;
-	unsigned int h; /* = win height - bar height */
-	unsigned int bw;
-
-	struct {
-		int w;
-		int h;
-		Pixmap pm;
-	} buf;
-
-	struct {
-		unsigned int h;
-		win_bar_t l;
-		win_bar_t r;
-	} bar;
+  Window xwin;
+  win_env_t env;
+
+  XftColor bg;
+  XftColor fg;
+
+  int x;
+  int y;
+  unsigned int w;
+  unsigned int h; /* = win height - bar height */
+  unsigned int bw;
+
+  struct {
+    int w;
+    int h;
+    Pixmap pm;
+  } buf;
+
+  struct {
+    unsigned int h;
+    win_bar_t l;
+    win_bar_t r;
+  } bar;
 };
 
 extern Atom atoms[ATOM_COUNT];
 
-void win_init(win_t*);
-void win_open(win_t*);
-CLEANUP void win_close(win_t*);
-bool win_configure(win_t*, XConfigureEvent*);
-void win_toggle_fullscreen(win_t*);
-void win_toggle_bar(win_t*);
-void win_clear(win_t*);
-void win_draw(win_t*);
-void win_draw_rect(win_t*, int, int, int, int, bool, int, unsigned long);
-void win_set_title(win_t*, const char*);
-void win_set_cursor(win_t*, cursor_t);
-void win_cursor_pos(win_t*, int*, int*);
+void win_init(win_t *);
+void win_open(win_t *);
+CLEANUP void win_close(win_t *);
+bool win_configure(win_t *, XConfigureEvent *);
+void win_toggle_fullscreen(win_t *);
+void win_toggle_bar(win_t *);
+void win_clear(win_t *);
+void win_draw(win_t *);
+void win_draw_rect(win_t *, int, int, int, int, bool, int, unsigned long);
+void win_set_title(win_t *, const char *);
+void win_set_cursor(win_t *, cursor_t);
+void win_cursor_pos(win_t *, int *, int *);
 
 #endif /* SXIV_H */
-
diff --git a/window.c b/window.c
index 6f9a390..a4db7c9 100644
--- a/window.c
+++ b/window.c
@@ -22,27 +22,25 @@
 #include "icon/data.h"
 #include "utf8.h"
 
-#include <stdlib.h>
-#include <string.h>
-#include <locale.h>
-#include <X11/cursorfont.h>
 #include <X11/Xatom.h>
 #include <X11/Xresource.h>
+#include <X11/cursorfont.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
 
 #define RES_CLASS "Sxiv"
 
-enum {
-	H_TEXT_PAD = 5,
-	V_TEXT_PAD = 1
-};
+enum { H_TEXT_PAD = 5, V_TEXT_PAD = 1 };
 
 static struct {
-	int name;
-	Cursor icon;
-} cursors[CURSOR_COUNT] = {
-	{ XC_left_ptr }, { XC_dotbox }, { XC_watch },
-	{ XC_sb_left_arrow }, { XC_sb_right_arrow }
-};
+  int name;
+  Cursor icon;
+} cursors[CURSOR_COUNT] = {{XC_left_ptr},
+                           {XC_dotbox},
+                           {XC_watch},
+                           {XC_sb_left_arrow},
+                           {XC_sb_right_arrow}};
 
 static GC gc;
 
@@ -53,424 +51,420 @@ static int barheight;
 
 Atom atoms[ATOM_COUNT];
 
-void win_init_font(const win_env_t *e, const char *fontstr)
-{
-	if ((font = XftFontOpenName(e->dpy, e->scr, fontstr)) == NULL)
-		error(EXIT_FAILURE, 0, "Error loading font '%s'", fontstr);
-	fontheight = font->ascent + font->descent;
-	FcPatternGetDouble(font->pattern, FC_SIZE, 0, &fontsize);
-	barheight = fontheight + 2 * V_TEXT_PAD;
+void win_init_font(const win_env_t *e, const char *fontstr) {
+  if ((font = XftFontOpenName(e->dpy, e->scr, fontstr)) == NULL)
+    error(EXIT_FAILURE, 0, "Error loading font '%s'", fontstr);
+  fontheight = font->ascent + font->descent;
+  FcPatternGetDouble(font->pattern, FC_SIZE, 0, &fontsize);
+  barheight = fontheight + 2 * V_TEXT_PAD;
 }
 
-void win_alloc_color(const win_env_t *e, const char *name, XftColor *col)
-{
-	if (!XftColorAllocName(e->dpy, DefaultVisual(e->dpy, e->scr),
-	                       DefaultColormap(e->dpy, e->scr), name, col))
-	{
-		error(EXIT_FAILURE, 0, "Error allocating color '%s'", name);
-	}
+void win_alloc_color(const win_env_t *e, const char *name, XftColor *col) {
+  if (!XftColorAllocName(e->dpy, DefaultVisual(e->dpy, e->scr),
+                         DefaultColormap(e->dpy, e->scr), name, col)) {
+    error(EXIT_FAILURE, 0, "Error allocating color '%s'", name);
+  }
 }
 
-const char* win_res(XrmDatabase db, const char *name, const char *def)
-{
-	char *type;
-	XrmValue ret;
-
-	if (db != None &&
-	    XrmGetResource(db, name, name, &type, &ret) &&
-	    STREQ(type, "String"))
-	{
-		return ret.addr;
-	} else {
-		return def;
-	}
+const char *win_res(XrmDatabase db, const char *name, const char *def) {
+  char *type;
+  XrmValue ret;
+
+  if (db != None && XrmGetResource(db, name, name, &type, &ret) &&
+      STREQ(type, "String")) {
+    return ret.addr;
+  } else {
+    return def;
+  }
 }
 
-#define INIT_ATOM_(atom) \
-	atoms[ATOM_##atom] = XInternAtom(e->dpy, #atom, False);
-
-void win_init(win_t *win)
-{
-	win_env_t *e;
-	const char *bg, *fg, *f;
-	char *res_man;
-	XrmDatabase db;
-
-	memset(win, 0, sizeof(win_t));
-
-	e = &win->env;
-	if ((e->dpy = XOpenDisplay(NULL)) == NULL)
-		error(EXIT_FAILURE, 0, "Error opening X display");
-
-	e->scr = DefaultScreen(e->dpy);
-	e->scrw = DisplayWidth(e->dpy, e->scr);
-	e->scrh = DisplayHeight(e->dpy, e->scr);
-	e->vis = DefaultVisual(e->dpy, e->scr);
-	e->cmap = DefaultColormap(e->dpy, e->scr);
-	e->depth = DefaultDepth(e->dpy, e->scr);
-
-	if (setlocale(LC_CTYPE, "") == NULL || XSupportsLocale() == 0)
-		error(0, 0, "No locale support");
-
-	XrmInitialize();
-	res_man = XResourceManagerString(e->dpy);
-	db = res_man != NULL ? XrmGetStringDatabase(res_man) : None;
-
-	f = win_res(db, RES_CLASS ".font", "monospace-8");
-	win_init_font(e, f);
-
-	bg = win_res(db, RES_CLASS ".background", "white");
-	fg = win_res(db, RES_CLASS ".foreground", "black");
-	win_alloc_color(e, bg, &win->bg);
-	win_alloc_color(e, fg, &win->fg);
-
-	win->bar.l.size = BAR_L_LEN;
-	win->bar.r.size = BAR_R_LEN;
-	/* 3 padding bytes needed by utf8_decode */
-	win->bar.l.buf = emalloc(win->bar.l.size + 3);
-	win->bar.l.buf[0] = '\0';
-	win->bar.r.buf = emalloc(win->bar.r.size + 3);
-	win->bar.r.buf[0] = '\0';
-	win->bar.h = options->hide_bar ? 0 : barheight;
-
-	INIT_ATOM_(WM_DELETE_WINDOW);
-	INIT_ATOM_(_NET_WM_NAME);
-	INIT_ATOM_(_NET_WM_ICON_NAME);
-	INIT_ATOM_(_NET_WM_ICON);
-	INIT_ATOM_(_NET_WM_STATE);
-	INIT_ATOM_(_NET_WM_STATE_FULLSCREEN);
+#define INIT_ATOM_(atom) atoms[ATOM_##atom] = XInternAtom(e->dpy, #atom, False);
+
+void win_init(win_t *win) {
+  win_env_t *e;
+  const char *bg, *fg, *f;
+  char *res_man;
+  XrmDatabase db;
+
+  memset(win, 0, sizeof(win_t));
+
+  e = &win->env;
+  if ((e->dpy = XOpenDisplay(NULL)) == NULL)
+    error(EXIT_FAILURE, 0, "Error opening X display");
+
+  e->scr = DefaultScreen(e->dpy);
+  e->scrw = DisplayWidth(e->dpy, e->scr);
+  e->scrh = DisplayHeight(e->dpy, e->scr);
+  e->vis = DefaultVisual(e->dpy, e->scr);
+  e->cmap = DefaultColormap(e->dpy, e->scr);
+  e->depth = DefaultDepth(e->dpy, e->scr);
+
+  if (setlocale(LC_CTYPE, "") == NULL || XSupportsLocale() == 0)
+    error(0, 0, "No locale support");
+
+  XrmInitialize();
+  res_man = XResourceManagerString(e->dpy);
+  db = res_man != NULL ? XrmGetStringDatabase(res_man) : None;
+
+  f = win_res(db, RES_CLASS ".font", "monospace-8");
+  win_init_font(e, f);
+
+  bg = win_res(db, RES_CLASS ".background", "white");
+  fg = win_res(db, RES_CLASS ".foreground", "black");
+  win_alloc_color(e, bg, &win->bg);
+  win_alloc_color(e, fg, &win->fg);
+
+  win->bar.l.size = BAR_L_LEN;
+  win->bar.r.size = BAR_R_LEN;
+  /* 3 padding bytes needed by utf8_decode */
+  win->bar.l.buf = emalloc(win->bar.l.size + 3);
+  win->bar.l.buf[0] = '\0';
+  win->bar.r.buf = emalloc(win->bar.r.size + 3);
+  win->bar.r.buf[0] = '\0';
+  win->bar.h = options->hide_bar ? 0 : barheight;
+
+  INIT_ATOM_(WM_DELETE_WINDOW);
+  INIT_ATOM_(_NET_WM_NAME);
+  INIT_ATOM_(_NET_WM_ICON_NAME);
+  INIT_ATOM_(_NET_WM_ICON);
+  INIT_ATOM_(_NET_WM_STATE);
+  INIT_ATOM_(_NET_WM_STATE_FULLSCREEN);
+  INIT_ATOM_(_NET_WM_STATE_ABOVE);
 }
 
-void win_open(win_t *win)
-{
-	int c, i, j, n;
-	long parent;
-	win_env_t *e;
-	XClassHint classhint;
-	unsigned long *icon_data;
-	XColor col;
-	Cursor *cnone = &cursors[CURSOR_NONE].icon;
-	char none_data[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
-	Pixmap none;
-	int gmask;
-	XSizeHints sizehints;
-
-	e = &win->env;
-	parent = options->embed != 0 ? options->embed : RootWindow(e->dpy, e->scr);
-
-	sizehints.flags = PWinGravity;
-	sizehints.win_gravity = NorthWestGravity;
-
-	/* determine window offsets, width & height */
-	if (options->geometry == NULL)
-		gmask = 0;
-	else
-		gmask = XParseGeometry(options->geometry, &win->x, &win->y,
-		                       &win->w, &win->h);
-	if ((gmask & WidthValue) != 0)
-		sizehints.flags |= USSize;
-	else
-		win->w = WIN_WIDTH;
-	if ((gmask & HeightValue) != 0)
-		sizehints.flags |= USSize;
-	else
-		win->h = WIN_HEIGHT;
-	if ((gmask & XValue) != 0) {
-		if ((gmask & XNegative) != 0) {
-			win->x += e->scrw - win->w;
-			sizehints.win_gravity = NorthEastGravity;
-		}
-		sizehints.flags |= USPosition;
-	} else {
-		win->x = 0;
-	}
-	if ((gmask & YValue) != 0) {
-		if ((gmask & YNegative) != 0) {
-			win->y += e->scrh - win->h;
-			sizehints.win_gravity = sizehints.win_gravity == NorthEastGravity
-			                      ? SouthEastGravity : SouthWestGravity;
-		}
-		sizehints.flags |= USPosition;
-	} else {
-		win->y = 0;
-	}
-
-	win->xwin = XCreateWindow(e->dpy, parent,
-	                          win->x, win->y, win->w, win->h, 0,
-	                          e->depth, InputOutput, e->vis, 0, NULL);
-	if (win->xwin == None)
-		error(EXIT_FAILURE, 0, "Error creating X window");
-
-	XSelectInput(e->dpy, win->xwin,
-	             ButtonReleaseMask | ButtonPressMask | KeyPressMask |
-	             PointerMotionMask | StructureNotifyMask);
-
-	for (i = 0; i < ARRLEN(cursors); i++) {
-		if (i != CURSOR_NONE)
-			cursors[i].icon = XCreateFontCursor(e->dpy, cursors[i].name);
-	}
-	if (XAllocNamedColor(e->dpy, DefaultColormap(e->dpy, e->scr), "black",
-	                     &col, &col) == 0)
-	{
-		error(EXIT_FAILURE, 0, "Error allocating color 'black'");
-	}
-	none = XCreateBitmapFromData(e->dpy, win->xwin, none_data, 8, 8);
-	*cnone = XCreatePixmapCursor(e->dpy, none, none, &col, &col, 0, 0);
-
-	gc = XCreateGC(e->dpy, win->xwin, 0, None);
-
-	n = icons[ARRLEN(icons)-1].size;
-	icon_data = emalloc((n * n + 2) * sizeof(*icon_data));
-
-	for (i = 0; i < ARRLEN(icons); i++) {
-		n = 0;
-		icon_data[n++] = icons[i].size;
-		icon_data[n++] = icons[i].size;
-
-		for (j = 0; j < icons[i].cnt; j++) {
-			for (c = icons[i].data[j] >> 4; c >= 0; c--)
-				icon_data[n++] = icon_colors[icons[i].data[j] & 0x0F];
-		}
-		XChangeProperty(e->dpy, win->xwin,
-		                atoms[ATOM__NET_WM_ICON], XA_CARDINAL, 32,
-		                i == 0 ? PropModeReplace : PropModeAppend,
-		                (unsigned char *) icon_data, n);
-	}
-	free(icon_data);
-
-	win_set_title(win, "sxiv");
-
-	classhint.res_class = RES_CLASS;
-	classhint.res_name = options->res_name != NULL ? options->res_name : "sxiv";
-	XSetClassHint(e->dpy, win->xwin, &classhint);
-
-	XSetWMProtocols(e->dpy, win->xwin, &atoms[ATOM_WM_DELETE_WINDOW], 1);
-
-	sizehints.width = win->w;
-	sizehints.height = win->h;
-	sizehints.x = win->x;
-	sizehints.y = win->y;
-	XSetWMNormalHints(win->env.dpy, win->xwin, &sizehints);
-
-	win->h -= win->bar.h;
-
-	win->buf.w = e->scrw;
-	win->buf.h = e->scrh;
-	win->buf.pm = XCreatePixmap(e->dpy, win->xwin,
-	                            win->buf.w, win->buf.h, e->depth);
-	XSetForeground(e->dpy, gc, win->bg.pixel);
-	XFillRectangle(e->dpy, win->buf.pm, gc, 0, 0, win->buf.w, win->buf.h);
-	XSetWindowBackgroundPixmap(e->dpy, win->xwin, win->buf.pm);
-
-	XMapWindow(e->dpy, win->xwin);
-	XFlush(e->dpy);
-
-	if (options->fullscreen)
-		win_toggle_fullscreen(win);
+void win_open(win_t *win) {
+  int c, i, j, n;
+  long parent;
+  win_env_t *e;
+  XClassHint classhint;
+  unsigned long *icon_data;
+  XColor col;
+  Cursor *cnone = &cursors[CURSOR_NONE].icon;
+  char none_data[] = {0, 0, 0, 0, 0, 0, 0, 0};
+  Pixmap none;
+  int gmask;
+  XSizeHints sizehints;
+
+  e = &win->env;
+  parent = options->embed != 0 ? options->embed : RootWindow(e->dpy, e->scr);
+
+  sizehints.flags = PWinGravity;
+  sizehints.win_gravity = NorthWestGravity;
+
+  /* determine window offsets, width & height */
+  if (options->geometry == NULL)
+    gmask = 0;
+  else
+    gmask =
+        XParseGeometry(options->geometry, &win->x, &win->y, &win->w, &win->h);
+  if ((gmask & WidthValue) != 0)
+    sizehints.flags |= USSize;
+  else
+    win->w = WIN_WIDTH;
+  if ((gmask & HeightValue) != 0)
+    sizehints.flags |= USSize;
+  else
+    win->h = WIN_HEIGHT;
+  if ((gmask & XValue) != 0) {
+    if ((gmask & XNegative) != 0) {
+      win->x += e->scrw - win->w;
+      sizehints.win_gravity = NorthEastGravity;
+    }
+    sizehints.flags |= USPosition;
+  } else {
+    win->x = 0;
+  }
+  if ((gmask & YValue) != 0) {
+    if ((gmask & YNegative) != 0) {
+      win->y += e->scrh - win->h;
+      sizehints.win_gravity = sizehints.win_gravity == NorthEastGravity
+                                  ? SouthEastGravity
+                                  : SouthWestGravity;
+    }
+    sizehints.flags |= USPosition;
+  } else {
+    win->y = 0;
+  }
+
+  win->xwin = XCreateWindow(e->dpy, parent, win->x, win->y, win->w, win->h, 0,
+                            e->depth, InputOutput, e->vis, 0, NULL);
+  if (win->xwin == None)
+    error(EXIT_FAILURE, 0, "Error creating X window");
+
+  XSelectInput(e->dpy, win->xwin,
+               ButtonReleaseMask | ButtonPressMask | KeyPressMask |
+                   PointerMotionMask | StructureNotifyMask);
+
+  for (i = 0; i < ARRLEN(cursors); i++) {
+    if (i != CURSOR_NONE)
+      cursors[i].icon = XCreateFontCursor(e->dpy, cursors[i].name);
+  }
+  if (XAllocNamedColor(e->dpy, DefaultColormap(e->dpy, e->scr), "black", &col,
+                       &col) == 0) {
+    error(EXIT_FAILURE, 0, "Error allocating color 'black'");
+  }
+  none = XCreateBitmapFromData(e->dpy, win->xwin, none_data, 8, 8);
+  *cnone = XCreatePixmapCursor(e->dpy, none, none, &col, &col, 0, 0);
+
+  gc = XCreateGC(e->dpy, win->xwin, 0, None);
+
+  n = icons[ARRLEN(icons) - 1].size;
+  icon_data = emalloc((n * n + 2) * sizeof(*icon_data));
+
+  for (i = 0; i < ARRLEN(icons); i++) {
+    n = 0;
+    icon_data[n++] = icons[i].size;
+    icon_data[n++] = icons[i].size;
+
+    for (j = 0; j < icons[i].cnt; j++) {
+      for (c = icons[i].data[j] >> 4; c >= 0; c--)
+        icon_data[n++] = icon_colors[icons[i].data[j] & 0x0F];
+    }
+    XChangeProperty(e->dpy, win->xwin, atoms[ATOM__NET_WM_ICON], XA_CARDINAL,
+                    32, i == 0 ? PropModeReplace : PropModeAppend,
+                    (unsigned char *)icon_data, n);
+  }
+  free(icon_data);
+
+  win_set_title(win, "sxiv");
+
+  classhint.res_class = RES_CLASS;
+  classhint.res_name = options->res_name != NULL ? options->res_name : "sxiv";
+  XSetClassHint(e->dpy, win->xwin, &classhint);
+
+  XSetWMProtocols(e->dpy, win->xwin, &atoms[ATOM_WM_DELETE_WINDOW], 1);
+
+  sizehints.width = win->w;
+  sizehints.height = win->h;
+  sizehints.x = win->x;
+  sizehints.y = win->y;
+  XSetWMNormalHints(win->env.dpy, win->xwin, &sizehints);
+
+  win->h -= win->bar.h;
+
+  win->buf.w = e->scrw;
+  win->buf.h = e->scrh;
+  win->buf.pm =
+      XCreatePixmap(e->dpy, win->xwin, win->buf.w, win->buf.h, e->depth);
+  XSetForeground(e->dpy, gc, win->bg.pixel);
+  XFillRectangle(e->dpy, win->buf.pm, gc, 0, 0, win->buf.w, win->buf.h);
+  XSetWindowBackgroundPixmap(e->dpy, win->xwin, win->buf.pm);
+
+  XMapWindow(e->dpy, win->xwin);
+  XFlush(e->dpy);
+
+  if (options->always_on_top) {
+    // XSetWMProtocols(e->dpy, win->xwin, &atoms[ATOM__NET_WM_STATE_ABOVE], 1);
+    XEvent ev;
+    XClientMessageEvent *cm;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.type = ClientMessage;
+
+    cm = &ev.xclient;
+    cm->window = win->xwin;
+    cm->message_type = atoms[ATOM__NET_WM_STATE];
+    cm->format = 32;
+    cm->data.l[0] = 2; // toggle
+    cm->data.l[1] = atoms[ATOM__NET_WM_STATE_ABOVE];
+
+    XSendEvent(win->env.dpy, DefaultRootWindow(win->env.dpy), False,
+               SubstructureNotifyMask | SubstructureRedirectMask, &ev);
+  }
+
+  if (options->fullscreen)
+    win_toggle_fullscreen(win);
 }
 
-CLEANUP void win_close(win_t *win)
-{
-	int i;
+CLEANUP void win_close(win_t *win) {
+  int i;
 
-	for (i = 0; i < ARRLEN(cursors); i++)
-		XFreeCursor(win->env.dpy, cursors[i].icon);
+  for (i = 0; i < ARRLEN(cursors); i++)
+    XFreeCursor(win->env.dpy, cursors[i].icon);
 
-	XFreeGC(win->env.dpy, gc);
+  XFreeGC(win->env.dpy, gc);
 
-	XDestroyWindow(win->env.dpy, win->xwin);
-	XCloseDisplay(win->env.dpy);
+  XDestroyWindow(win->env.dpy, win->xwin);
+  XCloseDisplay(win->env.dpy);
 }
 
-bool win_configure(win_t *win, XConfigureEvent *c)
-{
-	bool changed;
+bool win_configure(win_t *win, XConfigureEvent *c) {
+  bool changed;
 
-	changed = win->w != c->width || win->h + win->bar.h != c->height;
+  changed = win->w != c->width || win->h + win->bar.h != c->height;
 
-	win->x = c->x;
-	win->y = c->y;
-	win->w = c->width;
-	win->h = c->height - win->bar.h;
-	win->bw = c->border_width;
+  win->x = c->x;
+  win->y = c->y;
+  win->w = c->width;
+  win->h = c->height - win->bar.h;
+  win->bw = c->border_width;
 
-	return changed;
+  return changed;
 }
 
-void win_toggle_fullscreen(win_t *win)
-{
-	XEvent ev;
-	XClientMessageEvent *cm;
+void win_toggle_fullscreen(win_t *win) {
+  XEvent ev;
+  XClientMessageEvent *cm;
 
-	memset(&ev, 0, sizeof(ev));
-	ev.type = ClientMessage;
+  memset(&ev, 0, sizeof(ev));
+  ev.type = ClientMessage;
 
-	cm = &ev.xclient;
-	cm->window = win->xwin;
-	cm->message_type = atoms[ATOM__NET_WM_STATE];
-	cm->format = 32;
-	cm->data.l[0] = 2; // toggle
-	cm->data.l[1] = atoms[ATOM__NET_WM_STATE_FULLSCREEN];
+  cm = &ev.xclient;
+  cm->window = win->xwin;
+  cm->message_type = atoms[ATOM__NET_WM_STATE];
+  cm->format = 32;
+  cm->data.l[0] = 2; // toggle
+  cm->data.l[1] = atoms[ATOM__NET_WM_STATE_FULLSCREEN];
 
-	XSendEvent(win->env.dpy, DefaultRootWindow(win->env.dpy), False,
-	           SubstructureNotifyMask | SubstructureRedirectMask, &ev);
+  XSendEvent(win->env.dpy, DefaultRootWindow(win->env.dpy), False,
+             SubstructureNotifyMask | SubstructureRedirectMask, &ev);
 }
 
-void win_toggle_bar(win_t *win)
-{
-	if (win->bar.h != 0) {
-		win->h += win->bar.h;
-		win->bar.h = 0;
-	} else {
-		win->bar.h = barheight;
-		win->h -= win->bar.h;
-	}
+void win_toggle_bar(win_t *win) {
+  if (win->bar.h != 0) {
+    win->h += win->bar.h;
+    win->bar.h = 0;
+  } else {
+    win->bar.h = barheight;
+    win->h -= win->bar.h;
+  }
 }
 
-void win_clear(win_t *win)
-{
-	win_env_t *e;
-
-	e = &win->env;
-
-	if (win->w > win->buf.w || win->h + win->bar.h > win->buf.h) {
-		XFreePixmap(e->dpy, win->buf.pm);
-		win->buf.w = MAX(win->buf.w, win->w);
-		win->buf.h = MAX(win->buf.h, win->h + win->bar.h);
-		win->buf.pm = XCreatePixmap(e->dpy, win->xwin,
-		                            win->buf.w, win->buf.h, e->depth);
-	}
-	XSetForeground(e->dpy, gc, win->bg.pixel);
-	XFillRectangle(e->dpy, win->buf.pm, gc, 0, 0, win->buf.w, win->buf.h);
+void win_clear(win_t *win) {
+  win_env_t *e;
+
+  e = &win->env;
+
+  if (win->w > win->buf.w || win->h + win->bar.h > win->buf.h) {
+    XFreePixmap(e->dpy, win->buf.pm);
+    win->buf.w = MAX(win->buf.w, win->w);
+    win->buf.h = MAX(win->buf.h, win->h + win->bar.h);
+    win->buf.pm =
+        XCreatePixmap(e->dpy, win->xwin, win->buf.w, win->buf.h, e->depth);
+  }
+  XSetForeground(e->dpy, gc, win->bg.pixel);
+  XFillRectangle(e->dpy, win->buf.pm, gc, 0, 0, win->buf.w, win->buf.h);
 }
 
-#define TEXTWIDTH(win, text, len) \
-	win_draw_text(win, NULL, NULL, 0, 0, text, len, 0)
+#define TEXTWIDTH(win, text, len)                                              \
+  win_draw_text(win, NULL, NULL, 0, 0, text, len, 0)
 
 int win_draw_text(win_t *win, XftDraw *d, const XftColor *color, int x, int y,
-                  char *text, int len, int w)
-{
-	int err, tw = 0;
-	char *t, *next;
-	uint32_t rune;
-	XftFont *f;
-	FcCharSet *fccharset;
-	XGlyphInfo ext;
-
-	for (t = text; t - text < len; t = next) {
-		next = utf8_decode(t, &rune, &err);
-		if (XftCharExists(win->env.dpy, font, rune)) {
-			f = font;
-		} else { /* fallback font */
-			fccharset = FcCharSetCreate();
-			FcCharSetAddChar(fccharset, rune);
-			f = XftFontOpen(win->env.dpy, win->env.scr, FC_CHARSET, FcTypeCharSet,
-			                fccharset, FC_SCALABLE, FcTypeBool, FcTrue,
-			                FC_SIZE, FcTypeDouble, fontsize, NULL);
-			FcCharSetDestroy(fccharset);
-		}
-		XftTextExtentsUtf8(win->env.dpy, f, (XftChar8*)t, next - t, &ext);
-		tw += ext.xOff;
-		if (tw <= w) {
-			XftDrawStringUtf8(d, color, f, x, y, (XftChar8*)t, next - t);
-			x += ext.xOff;
-		}
-		if (f != font)
-			XftFontClose(win->env.dpy, f);
-	}
-	return tw;
+                  char *text, int len, int w) {
+  int err, tw = 0;
+  char *t, *next;
+  uint32_t rune;
+  XftFont *f;
+  FcCharSet *fccharset;
+  XGlyphInfo ext;
+
+  for (t = text; t - text < len; t = next) {
+    next = utf8_decode(t, &rune, &err);
+    if (XftCharExists(win->env.dpy, font, rune)) {
+      f = font;
+    } else { /* fallback font */
+      fccharset = FcCharSetCreate();
+      FcCharSetAddChar(fccharset, rune);
+      f = XftFontOpen(win->env.dpy, win->env.scr, FC_CHARSET, FcTypeCharSet,
+                      fccharset, FC_SCALABLE, FcTypeBool, FcTrue, FC_SIZE,
+                      FcTypeDouble, fontsize, NULL);
+      FcCharSetDestroy(fccharset);
+    }
+    XftTextExtentsUtf8(win->env.dpy, f, (XftChar8 *)t, next - t, &ext);
+    tw += ext.xOff;
+    if (tw <= w) {
+      XftDrawStringUtf8(d, color, f, x, y, (XftChar8 *)t, next - t);
+      x += ext.xOff;
+    }
+    if (f != font)
+      XftFontClose(win->env.dpy, f);
+  }
+  return tw;
 }
 
-void win_draw_bar(win_t *win)
-{
-	int len, x, y, w, tw;
-	win_env_t *e;
-	win_bar_t *l, *r;
-	XftDraw *d;
-
-	if ((l = &win->bar.l)->buf == NULL || (r = &win->bar.r)->buf == NULL)
-		return;
-
-	e = &win->env;
-	y = win->h + font->ascent + V_TEXT_PAD;
-	w = win->w - 2*H_TEXT_PAD;
-	d = XftDrawCreate(e->dpy, win->buf.pm, DefaultVisual(e->dpy, e->scr),
-	                  DefaultColormap(e->dpy, e->scr));
-
-	XSetForeground(e->dpy, gc, win->fg.pixel);
-	XFillRectangle(e->dpy, win->buf.pm, gc, 0, win->h, win->w, win->bar.h);
-
-	XSetForeground(e->dpy, gc, win->bg.pixel);
-	XSetBackground(e->dpy, gc, win->fg.pixel);
-
-	if ((len = strlen(r->buf)) > 0) {
-		if ((tw = TEXTWIDTH(win, r->buf, len)) > w)
-			return;
-		x = win->w - tw - H_TEXT_PAD;
-		w -= tw;
-		win_draw_text(win, d, &win->bg, x, y, r->buf, len, tw);
-	}
-	if ((len = strlen(l->buf)) > 0) {
-		x = H_TEXT_PAD;
-		w -= 2 * H_TEXT_PAD; /* gap between left and right parts */
-		win_draw_text(win, d, &win->bg, x, y, l->buf, len, w);
-	}
-	XftDrawDestroy(d);
+void win_draw_bar(win_t *win) {
+  int len, x, y, w, tw;
+  win_env_t *e;
+  win_bar_t *l, *r;
+  XftDraw *d;
+
+  if ((l = &win->bar.l)->buf == NULL || (r = &win->bar.r)->buf == NULL)
+    return;
+
+  e = &win->env;
+  y = win->h + font->ascent + V_TEXT_PAD;
+  w = win->w - 2 * H_TEXT_PAD;
+  d = XftDrawCreate(e->dpy, win->buf.pm, DefaultVisual(e->dpy, e->scr),
+                    DefaultColormap(e->dpy, e->scr));
+
+  XSetForeground(e->dpy, gc, win->fg.pixel);
+  XFillRectangle(e->dpy, win->buf.pm, gc, 0, win->h, win->w, win->bar.h);
+
+  XSetForeground(e->dpy, gc, win->bg.pixel);
+  XSetBackground(e->dpy, gc, win->fg.pixel);
+
+  if ((len = strlen(r->buf)) > 0) {
+    if ((tw = TEXTWIDTH(win, r->buf, len)) > w)
+      return;
+    x = win->w - tw - H_TEXT_PAD;
+    w -= tw;
+    win_draw_text(win, d, &win->bg, x, y, r->buf, len, tw);
+  }
+  if ((len = strlen(l->buf)) > 0) {
+    x = H_TEXT_PAD;
+    w -= 2 * H_TEXT_PAD; /* gap between left and right parts */
+    win_draw_text(win, d, &win->bg, x, y, l->buf, len, w);
+  }
+  XftDrawDestroy(d);
 }
 
-void win_draw(win_t *win)
-{
-	if (win->bar.h > 0)
-		win_draw_bar(win);
+void win_draw(win_t *win) {
+  if (win->bar.h > 0)
+    win_draw_bar(win);
 
-	XSetWindowBackgroundPixmap(win->env.dpy, win->xwin, win->buf.pm);
-	XClearWindow(win->env.dpy, win->xwin);
-	XFlush(win->env.dpy);
+  XSetWindowBackgroundPixmap(win->env.dpy, win->xwin, win->buf.pm);
+  XClearWindow(win->env.dpy, win->xwin);
+  XFlush(win->env.dpy);
 }
 
 void win_draw_rect(win_t *win, int x, int y, int w, int h, bool fill, int lw,
-                   unsigned long col)
-{
-	XGCValues gcval;
-
-	gcval.line_width = lw;
-	gcval.foreground = col;
-	XChangeGC(win->env.dpy, gc, GCForeground | GCLineWidth, &gcval);
-
-	if (fill)
-		XFillRectangle(win->env.dpy, win->buf.pm, gc, x, y, w, h);
-	else
-		XDrawRectangle(win->env.dpy, win->buf.pm, gc, x, y, w, h);
+                   unsigned long col) {
+  XGCValues gcval;
+
+  gcval.line_width = lw;
+  gcval.foreground = col;
+  XChangeGC(win->env.dpy, gc, GCForeground | GCLineWidth, &gcval);
+
+  if (fill)
+    XFillRectangle(win->env.dpy, win->buf.pm, gc, x, y, w, h);
+  else
+    XDrawRectangle(win->env.dpy, win->buf.pm, gc, x, y, w, h);
 }
 
-void win_set_title(win_t *win, const char *title)
-{
-	XStoreName(win->env.dpy, win->xwin, title);
-	XSetIconName(win->env.dpy, win->xwin, title);
-
-	XChangeProperty(win->env.dpy, win->xwin, atoms[ATOM__NET_WM_NAME],
-	                XInternAtom(win->env.dpy, "UTF8_STRING", False), 8,
-	                PropModeReplace, (unsigned char *) title, strlen(title));
-	XChangeProperty(win->env.dpy, win->xwin, atoms[ATOM__NET_WM_ICON_NAME],
-	                XInternAtom(win->env.dpy, "UTF8_STRING", False), 8,
-	                PropModeReplace, (unsigned char *) title, strlen(title));
+void win_set_title(win_t *win, const char *title) {
+  XStoreName(win->env.dpy, win->xwin, title);
+  XSetIconName(win->env.dpy, win->xwin, title);
+
+  XChangeProperty(win->env.dpy, win->xwin, atoms[ATOM__NET_WM_NAME],
+                  XInternAtom(win->env.dpy, "UTF8_STRING", False), 8,
+                  PropModeReplace, (unsigned char *)title, strlen(title));
+  XChangeProperty(win->env.dpy, win->xwin, atoms[ATOM__NET_WM_ICON_NAME],
+                  XInternAtom(win->env.dpy, "UTF8_STRING", False), 8,
+                  PropModeReplace, (unsigned char *)title, strlen(title));
 }
 
-void win_set_cursor(win_t *win, cursor_t cursor)
-{
-	if (cursor >= 0 && cursor < ARRLEN(cursors)) {
-		XDefineCursor(win->env.dpy, win->xwin, cursors[cursor].icon);
-		XFlush(win->env.dpy);
-	}
+void win_set_cursor(win_t *win, cursor_t cursor) {
+  if (cursor >= 0 && cursor < ARRLEN(cursors)) {
+    XDefineCursor(win->env.dpy, win->xwin, cursors[cursor].icon);
+    XFlush(win->env.dpy);
+  }
 }
 
-void win_cursor_pos(win_t *win, int *x, int *y)
-{
-	int i;
-	unsigned int ui;
-	Window w;
+void win_cursor_pos(win_t *win, int *x, int *y) {
+  int i;
+  unsigned int ui;
+  Window w;
 
-	if (!XQueryPointer(win->env.dpy, win->xwin, &w, &w, &i, &i, x, y, &ui))
-		*x = *y = 0;
+  if (!XQueryPointer(win->env.dpy, win->xwin, &w, &w, &i, &i, x, y, &ui))
+    *x = *y = 0;
 }
-
